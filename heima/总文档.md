### 内联函数的引出-宏缺陷以及内联函数和编译器处理

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;
//定义一个加法
#define MyAdd(x,y) x+y
void test01(){
	int ret = MyAdd(10,20);
	cout << "ret = " << ret << endl;
}

#define MyCompare(a,b) ((a) < (b)) ? (a):(b)

void test02(){
	int a = 10;
	int b = 20;

	int ret = MyCompare(++a,b);
	cout << "ret = " << ret << endl;
}
// 1 内联函数注意事项
// 类内部的成员函数 默认前面会加inline 关键字
inline void func();//内联函数声明
inline void func(){};//如果函数实现时候，没有加inline关键字，那么这个函数依然不算内联函数


//但是C++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：
//1. 不能存在任何形式的循环语句
//2. 不能存在过多的条件判断语句
//3. 函数体不能过于庞大
//4. 不能对函数进行取址操作
//内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的，简单的函数。
int main(){
	test01();
      	test02();         	
	return 0;
}

```

### 函数默认参数以及占位参数

```c++
#include<iostream>
using namespace std;

//函数参数注意事项，如果有一个位置有了默认参数，那么从这个位置开始，从左往右都必须有默认参数
void func(int a,int b = 10,int c = 20){
	cout << "a + b + c = " << a + b + c << endl;
}

//函数 占位参数
//如果有了占位参数，函数调用时候必须提供这个参数，但是用不到这个参数
//占位参数 没什么大用途，只有后面重载++符号才有一点点用
//占用参数可以有默认参数
//C语言中没有默认参数，也没有占位参数
//
//
//如果函数声明里面有了默认参数，那么函数实现时候必须没有
//函数声明和实现里，只能有一个里面有默认参数，不能同时出现默认参数
void func2(int a,int = 1){

}
void test02(){
	func2(10,1);
}
int main(){
	return 0;
} 
```

### 函数重载的语法

```c++
#include<iostream>
using namespace std;

//函数重载
//C++中 函数名称可以重复
//必须在同一个作用域，函数名称
//函数的参数个数不同或者类型不同 或者顺序不同
void func(){
	cout << "无参数的func" << endl;
}

void func(int a){
	cout << "有参数的func(int a)" << endl;
}
void func(double a){
	cout << "有参数的func(double a)" << endl;
}
void func(double a,int b){
	cout << "有参数的func(double a,int b)" << endl;
}
void func(int a,double b){
	cout << "有参数的func(int a,double b)" << endl;
}

//返回值可以作为函数重载的条件吗？？？  不可以！！
//比如不对函数返回值做处理就会产生二义性

//当函数重载 碰到了默认参数的时候，要注意避免二义性问题
//例如下面:
void func2(int a,int b = 10){
}
void func2(int a){
}
//引用的重载版本

void func3(int &a){//引用必须引合法的内存空间
}
void func3(const int &a)//const 也可以作为重载的条件
{
	cout << "const int &a" << endl;
} 
void test03(){
	func3(10);
}
```

### 函数重载的实现原理

```c++
#include<iostream>
using namespace std;
//编译器用不同的参数类型来修饰不同的函数名
```

### C语言下的封装和C++ 的封装区别

```c++
#include<iostream>
using namespace std;

//C++中的封装 严格类型转换检测，让属性和行为绑定到一起
//属性和行为作为一个整体来表示生活中的事物
//public 在类内部和类外部都可以访问
//protected 类内部，和当前类的子类可以访问
//private 在类内部可以访问，类外部不可以访问 
```

```c
#include<stdio.h>


//C语言中成员和属性分开，而且没有严格的类型检测
//老王也吃了dog的狗粮
```

### 构造函数的分类及调用

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;

//分类
//按照参数进行分类：无参构造函数（默认构造函数） 有参构造函数
//按照类型进行分类 普通构造函数 拷贝构造函数
//

class Person{
public: //构造函数和析构函数必须写在public下才可以调用
	Person() //默认、无参构造函数
	{
		cout << "默认构造函数调用" << endl;
	}

	Person(int a){
		cout << "有参构造函数调用" << endl;
	}

	//拷贝构造函数，必须加const
	Person(const Person &p){
		cout << "拷贝构造函数调用" << endl;
	}

	~Person(){

	}

};

void test01(){
	//构造函数调用方式
	//括号调用
	Person p1(1);
	
	Person p2(p1);//拷贝

	Person p3;//默认构造函数不要加（）

	//Person p3(),编译器认为这是函数的声明
	//
	
	//显示法调用
	Person p4 = Person(100);
	Person p5 = Person(p4);

	//Person(100) //叫匿名对象
	//匿名对象特定，如果编译器发现了对象是匿名的，那么在这行代码结束后就释放这个对象
	
	//不能用拷贝构造函数 初始化匿名对象
	//Person（p5);//如果写成左值 ,编译器认为你写成Person p5;对象的声明，如果写成右值，那么可以
	//
	
	Person p7 = 100;//相当于调用了Person p7 = Person(100),隐式类型转换
	Person p8 = p7;//相当于 Person p8  = Person(p7)
}
```

### 拷贝构造函数调用时机

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class Person{
public:
	Person(){
		cout << "默认构造函数" << endl;
	}

	Person(int a){
		cout << "有参构造函数调用" << endl;
	}
	Person(const Person &p){
		//const 和 &都不能丢，丢了&参数传入时就会一直调用拷贝构造函数，死循环
		cout << "拷贝构造函数调用" << endl;
	}

	~Person(){
		cout << "析构函数调用" << endl;
	}

	int m_Age;
};

//拷贝构造函数调用时机
//1. 用已经创建好的对象来初始化新的对象
void test01(){
	Person p1;
	p1.m_Age = 10;

	Person p2(p1);
}


//2、以值传递的方式给函数传值


void dowork(Person p1)//Person p1 = Person(p)
{
}


//3、 以值方式返回局部对象

Person dowork2(){
	Person p1;
	return p1;
}
//编译器可能会做优化
void test03(){
	Person p = dowork2();
}
void test02(){
	Person p;
	p.m_Age = 10;
	doWork(p);
}
```

### 构造函数的调用规则

```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class MyClass{
public:
	MyClass(){
		cout << "默认构造函数" << endl;
	}

	MyClass(int a){
		cout << "有参构造函数" << endl;
	}
	

	int m_A;

};
//系统默认给一个类提供3个函数 默认构造、拷贝构造、析构函数
//
//
//1 当我们提供了有参构造函数，那么系统就不会再给我们提供默认构造函数了
//但是系统还会提供默认拷贝构造函数，进行简单的值拷贝


void test01(){
	MyClass c1(1);

	cl.m_A = 10;
	MyClass c2(c1);
	cout << c2.m_A << endl;

}


//2 当我们提供了拷贝构造函数，那么系统就不会提供其它构造了


class MyClass2{
public:
	Myclass2(const Myclass2 &m){
	}
};


int main(){


}
```

### 深拷贝和浅拷贝

```c++
#include<iostream>
using namespace std;

class Person{
public:
	Person(){
	}

	person(char *name,int age){
		m_Name = (char*)malloc(strlen(name) + 1);
		strcpy(m_Name,name);
		m_age = age;
	}
	
	//拷贝构造 系统会提供默认拷贝构造，而且是简单的值拷贝	
	//自己提供拷贝构造，原因简单的浅拷贝会释放堆区空间两次，导致挂掉
	
	Person(const Person &p){
		m_age = p.m_age;
		m_Name = (char*)malloc(strlen(p.m_Name) + 1);
		strcpy(m_Name,p.m_Name);
	}

	//如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常
	//解决上述问题，需要我们提供拷贝构造函数，进行深拷贝

	~Person(){
		cout << "析构函数调用" << endl;
		if(m_Name!=NULl){
			free(m_Name);
			m_Name = NULL;
		}
	}
	//姓名
	char *m_Name;

	//年龄
	int m_age;
};


void test01(){
	Person p1("敌法",10);
	Person p2(p1);//调用拷贝构造

}
```

### 初始化列表

```c++
#include<iostream>
using namespace std;

class Person{
public:
	Person(){}

	/*Person(int a,int b,int c){
		m_A = a;
		m_B = b;
		m_C = c;
	}*/

	Person(int a,int b,int c) : m_A(a),m_B(b),m_C(c){}

	int m_A;
	int m_B;
	int m_C;
};

void test01(){
	Person p1(10,20,30);

	cout << "p1的m_A :" << p1.m_A << endl;
	cout << "p1的m_B :" << p1.m_B << endl;
	cout << "p1的m_C :" << p1.m_C << endl;
}

int main(){
	test01();

	return 0;
}
```

### 类对象作为类成员的案例

```c++
#include<iostream>
#include<string>
using namespace std;


class Phone{
public:
	Phone(){
		cout << "手机的默认构造函数调用" << endl;
	Person(string name){
		m_PhoneName = name;
	}
	~Phone(){
		cout << "手机的析构函数调用" << endl;
	}
	string m_PhoneName;
};

class Game{
public:
	Game(){
		cout << "Game的默认构造函数调用" << endl;
	}

	Game(string name){
		m_GameName = name;
	}

	~Game(){
		cout << "Game的析构函数调用" << endl;
	}

	string m_GameName;
};
class Person{
public:
	Person(){
		cout << "Person的默认构造函数调用" << endl;
	}

	Person(string name，string phoneName,string gameName):m_Name(name),m_Phone(phoneName),m_Game(gameName){
		m_Name = name;
	}

	void playGame(){
		cout << m_Name << "拿着《" << m_Phone <<

	~Person(){
		cout << "Person 的析构函数调用" << endl;
	}

	string m_Name;
	Phone m_Phone;
	Game m_Game;
};


//类对象作为类成员时候，构造顺序先将类对象一一构造，然后构造自己，析构的顺序是相反的
void test01(){
	Person p;

}

int main(){

	test01();

	return 0;
}
```

### explicit关键字作用

```c++
#include<iostream>
#include<string>
using namespace std;
//explicit 防止隐式类型转换
class MyString{
public:
	MyString(const char *str){
		//
	}

	explicit MyString(int a){
	}//防止构造函数中的隐式类型转换。

	char* mStr;
};

void test01(){
	MyString str = "abc";
	MyString str2(10);
	MyString str3 = 10;//做什么用很不明显
	//隐式类型转换，MyString str3 = Mystring(10);
	//explicit关键字，防止隐式类型转换
}


int main(){

	return 0;
}
```

### new运算符的作用

```c++
#include<iostream>
using namespace std;
//char * arr = (char *)malloc(4*size_of(char))
//c使用molloc和free在堆区进行动态内存管理
//切记强制类型转换，返回void *
//有可能申请失败，返回NULL
//用户在使用这个对象之前必须对这个地址进行初始化

class Person
{
public:
	Person(){
		cout << "默认构造函数" << endl;
	}//注意有new开辟数组时一定会调用默认构造函数
	Person(int a){
		cout << "有参构造函数" << endl;
	}
	~Person(){
		cout << "析构函数调用" << endl;
	}
};
void test01(){
	//Person p1;栈区开辟
	Person *p2 = new Person;//堆区开辟
	//所有new出来的对象，都会返回该类型的指针
	//malloc 返回void* 还要强转
	//malloc会调用构造函数吗？不会，new会
	//new运算符，malloc函数
	//释放堆区空间
	delete p2;//delete也是一个运算符
}
void test02(){
	void *p = new Person;
	//当用void* 接受new出来的指针，会出现释放的问题
	delete p;
	//无法释放p
}
void test03(){
	//通过new开辟数组,一定会调用默认构造函数，所以一定要提供默认构造函数
	Person *pArray = new Person[10];
	Person pArray2[2] = {Person(1),Person(2)};//在栈上开辟数组，可以指定有参构造
	//释放数组
	delete [] pArray; 
}
int t(){
	Person *person = new Person;

	//相当于
	Person *person = (Person*)malloc(sizeof(Person));
	if(person == NULL){
		return 0;
	}
	person -> Init();//相当于构造函数、
	//New操作符能确定在调用构造函数初始化之前内存分配是成功的，所以不用显式确定调用是否成功
}
```